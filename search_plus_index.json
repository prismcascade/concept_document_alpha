{"./":{"url":"./","title":"概要","keywords":"","body":"1. PrismCascade とは 動画編集の基盤システム （C++製） プラグインによる柔軟な編集を目指す GUIの有無やOSにかかわらず動作可能なものを目指す 2. 基本構成 core 動画編集の制御を行う。 C++ライブラリの形で提供。 plugin 動画に対する操作の本体 Windowsでは .dll ファイル，Linuxでは .so ファイル UI 動画編集の補助やプレビューなどを行う。 coreに対して具体的な操作を要求する。 GUI と CUI 両方を作成予定 3. プラグイン plugins/ 以下に存在する dll / so ファイルを探索し，プラグインとして読み込む。 プラグインには Effect と Macro が存在する。 基本的には， Effect プラグインを組み合わせることで映像編集を行う。 各プラグインは1つの主出力と，0～∞個の副出力を持つ 各プラグインはパラメータをいくつか持つことが出来て，以下の3つの方法で値を入力できる。 値の直接指定 埋め込んだ他 Effect プラグインの主出力 他の Effect プラグインの副出力の参照 4. 目指す物 プラットフォーム非依存 少なくとも Windows, Linux で動作する物を目指す UI と 処理の分離 将来的にUIを差し替えたり自動処理スクリプトからの呼び出し等をする際に，互換性を容易に保てる コミュニティによりプラグインが活発に作成される状態を目指す 5. 開発理念 拡張性重視 本体の機能を簡潔にする プラグインを中心に添える 堅牢な設計 型検査をする 全てのUI操作をエフェクトASTの操作と対応させる 1. PrismCascade とは2. 基本構成3. プラグイン4. 目指す物5. 開発理念"},"architecture/memo_01.html":{"url":"architecture/memo_01.html","title":"未整理のメモ","keywords":"","body":"きれいにまとめる前のメモ 1. 作ろうとしているもの 名前は「Prism Cascade」 C++ で実装 動画編集用の基盤 プラグイン用の規格も含む OS非依存のライブラリとして実装 UIと分離した存在 動画作成・生放送ともに対応 デバッグツールや可視化を作りやすくする 2. AST 2.1. 着想 プラグインのインスタンスをノードとするようなASTを構築する タイムライン上には関数型プログラミングとしてのASTを構築する 変数束縛のアナロジーとして，補助的に副出力を用いることもできる DAGが必要な時のために副出力を許容するが，基本的にはきれいな構造を保ってほしいので，主出力は木構造，副出力はDAGというようにした。 GUIでの処理をASTの処理にマッピングする エフェクトを重ねがけして Z[Y[X[A]]] となってるのをUI側で A(エフェクト: X, Y, Z) と変換して表示する (詳細は要検討) 主出力と副出力を分けたことで，このUIとのマッピングしやすくなると考えられる。 2.2. 入力 各ノードは任意個の入力を持つ 入力に取れるのは以下のいずれか 即値 他プラグインの主出力 自分のみが取得できる 他プラグインの副出力 任意個の入力の間で共有できる 各入力は， look-ahead と look-behind (後述) を持つ 2.3. 出力 各ノードは1個以上の出力を持つ 最初の出力は「主出力」であり，UI上でも親子関係を構築する 2番目以降の出力は「副出力」であり，任意の場所から参照できる ただし，循環を作ることは許可されない 各ノードは，出力fpsの値(有理数)を持つ 入力によって決めてもよい （1フレーム目がレンダリングされる前に，最初に訊いて回る） fps=0の時，この値は「いつでも必要なときに計算される」ことを示す 2.4. 木構造 Effect のプラグインをノードとし，主出力の入力を親子関係とする木を構築する 値の上書き等で主出力を上書きした際には，ASTノードごと消滅する （副出力も消える） 3. 代入 代入によりASTノードが消滅することがある サブツリーとメインツリーに分け，間に存在する副出力の参照を全て切断する処理をしている Undo と Redo では，再び繋ぎなおす必要がある ASTに属するノードがASTの別の箇所に代入された場合，元の場所からは居なくなる。 sub_edge はそのまま （切断することもできる） ノードがあった場所に別の値を上書きすると，そこにあったノードは消滅する 値としては，即値，SubEdge（副出力の取得），ASTノード（主出力の取得）を置ける 主出力部分で 4. マクロ (未実装) Macro のプラグインは AST を生成できる （2025/04/08 時点で未実装） 実体を生み出すわけではなく，レンダリング時のみ生成される仮のサブツリーを生成する 実体化した上で，手動で編集することもできる 5. 型 5.1. 基本型 Int C++ の std::int64_t 型と対応 Bool C++ の bool 型と対応 Float C++ の double 型と対応 Text 文字列 （2^32 バイト未満） Video 映像型 height, width は 2^32 未満 フレーム数は 2^64 未満 将来的に生放送に対応した場合に桁あふれを防ぐために多めに桁数を持たせている Audio 音声型 詳細は未定 Vector 上記の型の可変長配列 （2^32 個未満） 中に Vector は入れられない (即値の扱いに困るのと，可視化が難しくなるため) 6. スケジューリング 6.1. トポロジカルソート 主出力と副出力両方の参照関係を用いて，トポロジカルソートを行う。 トポロジカルソートに失敗した場合にはスケジューリング不能としてレンダリングに失敗する 6.2. 非因果的システム 例えば逆再生などは代表的な非因果的システム 入力パラメータ全体について，未来の値を取れる必要がある 各入力に対し，look-ahead, look-behind の値を取る そのエフェクトが発生した時点での，各入力の最新値よりも look-ahead フレーム先と look-behind フレーム前（入力値準拠）を読む必要があることを言明する 原理上， look-behind + look-ahead >= 0 である。 例えば， look-behind = 100, look-ahead = -100 というのも可能 例として，100フレーム前のものを出力し，最初の100フレームはカウントダウン，みたいなエフェクトがこれに該当する ここでは，エフェクトを以下の３種類に分ける 群遅延付きエフェクト look-ahead = look-behind = 0 リアルタイムエフェクト look-ahead と look-behind がともに有限確定値 強非因果的システム その他 (look-ahead, look-behind = std::nullopt とする) スケジューリング時に，代わりに「入力の全体長」がそれぞれに入力されているとみなして処理する 入力の長さが不定（生放送）かつ強い非因果的システムの場合，スケジューリングに失敗する 6.3. スケジューリング 6.3.1. 基本 トポロジカルソートした結果を rank と呼ぶ （葉ノードの一つは0, 根ノードは最大値で，連番の整数が振られる） 各ノードについて「最後に計算された時刻」を記録しておく 時間は， fps の分子の最小公倍数をもとに全て整数化し，それを timestamp と呼ぶ (128bit整数)。 最終的には， priority_queue> から取り出して順に処理していく 処理が終わったら，自分自身を次の timestamp でキューに入れる （fps=0の時を除く） 入力が fps=0 かつ，今の timestamp において未処理なら，それを pair{timestamp, rank-1} に入れて，自分自身も今の時刻で入れなおす6.3.2. 遅延計算 主出力・副出力両方において，出力ノードのdelay + (look_aheadf×fps分子の最小公倍数/自分のfps) の値を超えない最小の値になる rootから辿ることで決定できる 各変数は， (Δtimestamp, rank) の寿命を持つ。Δtimestampは，各消費に対して (look-ahead + look-behind - (delay(destination) - delay(source)) × 自分のfps / fps分子の最小公倍数) の値(割り算は切り上げ)の最大値。0の場合もあるが，最後に消費されるrankの方が効くことで，変数寿命の管理がなされる。 6.3.3. キャッシング 各値はメモリ上にキャッシングされる。 ただし，動画についてのみ，キャッシュを適宜ストレージ側に適宜落とす。 生放送の時には，メモリに乗せる量の上限を非常に大きい値（実質の無制限）にすることが推奨される。 6.3.4. 並列処理 (未実装) priority_queue> で先頭からどんどん取り出して， semaphore で最大数を管理しつつ並列処理する形になると思う キューが複数になってしまうのは困るので，設計を考え中 6.4. 特筆すべき実例 入力の再生 → 逆再生 を繰り返すエフェクトは，強非因果エフェクトなので，生放送のカメラに対して適用すると，スケジューリングに失敗する しかし，同様に生放送中に「全体が1秒の動画」に対してこれを適用すると，１秒の遅延で済み，スケジューリング可能。 100フレーム遅延するエフェクトの後に「最初の100フレームはカウントダウンをした後に，100フレーム前の動画を再生するエフェクト（look-ahead = -100, look-behind = 100）」を入れると，遅延は0になる。 きれいにまとめる前のメモ1. 作ろうとしているもの2. AST2.1. 着想2.2. 入力2.3. 出力2.4. 木構造3. 代入4. マクロ (未実装)5. 型5.1. 基本型6. スケジューリング6.1. トポロジカルソート6.2. 非因果的システム6.3. スケジューリング6.3.1. 基本6.3.2. 遅延計算6.3.3. キャッシング6.3.4. 並列処理 (未実装)6.4. 特筆すべき実例"},"architecture/types.html":{"url":"architecture/types.html","title":"型","keywords":"","body":"1. 型 1.1. 基本型 Int C++ の std::int64_t 型と対応 Bool C++ の bool 型と対応 Float C++ の double 型と対応 Text 文字列 （2^32 バイト未満） Video 映像型 height, width は 2^32 未満 フレーム数は 2^64 未満 将来的に生放送に対応した場合に桁あふれを防ぐために多めに桁数を持たせている Audio 音声型 詳細は未定 Vector 上記の型の可変長配列 （2^32 個未満） 中に Vector は入れられない 1. 型1.1. 基本型"},"architecture/ast.html":{"url":"architecture/ast.html","title":"抽象構文木","keywords":"","body":"1. 抽象構文木 (AST) 1.1. 着想 タイムライン上には関数型プログラミングとしてのASTを構築する 変数束縛として補助的に副出力を用いることもできる 単なるノードベースプログラミングとしてのDAGを構築するのに比べて，構造化する理由が発生するという意図 1.2. 入力 各ノードは任意個の入力を持つ 入力に取れるのは以下のいずれか 即値 他プラグインの主出力 自分のみが取得できる 他プラグインの副出力 任意個の入力で共有できる 1.3. 出力 各ノードは1個以上の出力を持つ 最初の出力は「主出力」であり，UI上でも親子関係を構築する 2番目以降の出力は「副出力」であり，任意の場所から参照できる ただし，循環を作ることは許可されない 1.4. 木構造 Effect のプラグインをノードとし，主出力の入力を親子関係とする木を構築する 値の上書き等で主出力を上書きした際には，ASTノードごと消滅する （副出力も消える） 2. 代入 代入によりASTノードが消滅することがある サブツリーとメインツリーに分け，間に存在する副出力の参照を全て切断する処理をしている Undo と Redo では，再び繋ぎなおす必要がある （2025/04/08 時点で未実装） 3. マクロ Macro のプラグインは AST を生成できる （2025/04/08 時点で未実装） 実体を生み出すわけではなく，レンダリング時のみ生成される仮のサブツリーを生成する 実体化した上で，手動で編集することもできる 4. スケジューリング 4.1. トポロジカルソート 主出力と副出力両方の参照関係を用いて，トポロジカルソートを行う。 トポロジカルソートに失敗した場合にはスケジューリング不能としてレンダリングに失敗する 1フレームずつ，順に呼び出すことで各フレームを生成する 4.2. 非因果的システム 例えば逆再生などは代表的な非因果的システム 入力パラメータ全体について，未来の値を取れる必要がある トポロジカルソート結果を，非因果的システムを根とするノード群に切り分ける それらを1フレームずつ，順に呼び出して各フレームを生成する 後続の処理で使う変数のみ，全フレーム分を保持する 1. 抽象構文木 (AST)1.1. 着想1.2. 入力1.3. 出力1.4. 木構造2. 代入3. マクロ4. スケジューリング4.1. トポロジカルソート4.2. 非因果的システム"},"architecture/layer_rendering.html":{"url":"architecture/layer_rendering.html","title":"レイヤー構造（レンダリング）","keywords":"","body":"1. 全体像 下位レイヤーから順に，以下の4層で構成されている Pluginメモリ管理層 Plugin層 キャッシュ管理層 スケジューリング層 2. Pluginメモリ管理層 2.1. 役割 TODO: 書く 2.2. 可能な操作 TODO: 書く 3. Plugin層 3.1. 役割 TODO: 書く 3.2. 可能な操作 TODO: 書く 4. キャッシュ管理層 4.1. 役割 TODO: 書く 4.2. 可能な操作 TODO: 書く 5. スケジューリング層 5.1. 役割 TODO: 書く 5.2. 可能な操作 TODO: 書く 1. 全体像2. Pluginメモリ管理層2.1. 役割2.2. 可能な操作3. Plugin層3.1. 役割3.2. 可能な操作4. キャッシュ管理層4.1. 役割4.2. 可能な操作5. スケジューリング層5.1. 役割5.2. 可能な操作"},"architecture/layer_ast.html":{"url":"architecture/layer_ast.html","title":"レイヤー構造（AST管理）","keywords":"","body":"1. 全体像 下位レイヤーから順に，以下の4層で構成されている AST構築＆プラグイン情報管理層 AST変形層 AST操作層 UI翻訳層 2. AST構築＆プラグイン情報管理層 2.1. 役割 TODO: 書く 2.2. 可能な操作 TODO: 書く 3. AST変形層 3.1. 役割 TODO: 書く 3.2. 可能な操作 TODO: 書く 4. AST操作層 4.1. 役割 TODO: 書く 4.2. 可能な操作 TODO: 書く 4.3. 履歴管理 TODO: 書く 5. UI翻訳層 5.1. 役割 TODO: 書く 5.2. 可能な操作 TODO: 書く 1. 全体像2. AST構築＆プラグイン情報管理層2.1. 役割2.2. 可能な操作3. AST変形層3.1. 役割3.2. 可能な操作4. AST操作層4.1. 役割4.2. 可能な操作4.3. 履歴管理5. UI翻訳層5.1. 役割5.2. 可能な操作"},"architecture/ui_ast.html":{"url":"architecture/ui_ast.html","title":"UIとAST","keywords":"","body":"1. 概要 TODO: 書く 2. エフェクトのリスト表示 2.1. ASTからUIへの変換 TODO: 書く 2.2. UIからASTへの変換 TODO: 書く 3. トランジション 3.1. ASTからUIへの変換 TODO: 書く 3.2. UIからASTへの変換 TODO: 書く 4. マクロの展開表示 4.1. ASTからUIへの変換 TODO: 書く 4.2. UIからASTへの変換 TODO: 書く 5. レイヤーの表示 5.1. ASTからUIへの変換 TODO: 書く 5.2. UIからASTへの変換 TODO: 書く 1. 概要2. エフェクトのリスト表示2.1. ASTからUIへの変換2.2. UIからASTへの変換3. トランジション3.1. ASTからUIへの変換3.2. UIからASTへの変換4. マクロの展開表示4.1. ASTからUIへの変換4.2. UIからASTへの変換5. レイヤーの表示5.1. ASTからUIへの変換5.2. UIからASTへの変換"},"architecture/macro.html":{"url":"architecture/macro.html","title":"マクロ展開","keywords":"","body":"1. 概要 TODO: 書く 2. プラグイン側の情報 TODO: 書く 3. 処理例 TODO: 書く 4. UIでの表示例 TODO: 書く 1. 概要2. プラグイン側の情報3. 処理例4. UIでの表示例"},"architecture/scheduling.html":{"url":"architecture/scheduling.html","title":"スケジューリング","keywords":"","body":"1. 概要 TODO: 書く トポロジカルソートして，変数寿命の管理とかをしている 2. 処理内容 2.1. レンダリング時の挙動 TODO: 書く 並列処理する 非因果的エフェクトの前は一旦全部レンダリングする 2.2. 実装未定： 再帰的レンダリング処理 TODO: 書く 直列処理する 非因果的エフェクトとか関係なく，要求された部分のみを計算する 2.3. 実装未定： Dirtyフラグの実装 TODO: 書く Dirtyな部分だけ再レンダリングする 1. 概要2. 処理内容2.1. レンダリング時の挙動2.2. 実装未定： 再帰的レンダリング処理2.3. 実装未定： Dirtyフラグの実装"}}