# きれいにまとめる前のメモ

## 作ろうとしているもの
- 名前は「Prism Cascade」
- C++ で実装
- 動画編集用の基盤
	- プラグイン用の規格も含む
	- OS非依存のライブラリとして実装
	- UIと分離した存在
	- 動画作成・生放送ともに対応
	- デバッグツールや可視化を作りやすくする

## AST
### 着想
- プラグインのインスタンスをノードとするようなASTを構築する
	- タイムライン上には関数型プログラミングとしてのASTを構築する
- 変数束縛のアナロジーとして，補助的に副出力を用いることもできる
	- DAGが必要な時のために副出力を許容するが，基本的にはきれいな構造を保ってほしいので，主出力は木構造，副出力はDAGというようにした。
- GUIでの処理をASTの処理にマッピングする
	- エフェクトを重ねがけして `Z[Y[X[A]]]` となってるのをUI側で `A(エフェクト: X, Y, Z)` と変換して表示する (詳細は要検討)
		- 主出力と副出力を分けたことで，このUIとのマッピングしやすくなると考えられる。

### 入力
- 各ノードは任意個の入力を持つ
	- 入力に取れるのは以下のいずれか
		- 即値
		- 他プラグインの主出力
			- 自分のみが取得できる
		- 他プラグインの副出力
			- 任意個の入力の間で共有できる
- 各入力は， look-ahead と look-behind (後述) を持つ

### 出力
- 各ノードは1個以上の出力を持つ
	- 最初の出力は「主出力」であり，UI上でも親子関係を構築する
	- 2番目以降の出力は「副出力」であり，任意の場所から参照できる
		- ただし，循環を作ることは許可されない
- 各ノードは，出力fpsの値(有理数)を持つ
	- 入力によって決めてもよい （1フレーム目がレンダリングされる前に，最初に訊いて回る）
	- fps=0の時，この値は「いつでも必要なときに計算される」ことを示す

### 木構造
- Effect のプラグインをノードとし，主出力の入力を親子関係とする木を構築する
	- 値の上書き等で主出力を上書きした際には，ASTノードごと消滅する （副出力も消える）

## 代入
- 代入によりASTノードが消滅することがある
	- サブツリーとメインツリーに分け，間に存在する副出力の参照を全て切断する処理をしている
- Undo と Redo では，再び繋ぎなおす必要がある
- ASTに属するノードがASTの別の箇所に代入された場合，元の場所からは居なくなる。
	- sub_edge はそのまま （切断することもできる）
- ノードがあった場所に別の値を上書きすると，そこにあったノードは消滅する
- 値としては，即値，SubEdge（副出力の取得），ASTノード（主出力の取得）を置ける
- 主出力部分で

## マクロ (未実装)
- Macro のプラグインは AST を生成できる （2025/04/08 時点で未実装）
	- 実体を生み出すわけではなく，レンダリング時のみ生成される仮のサブツリーを生成する
	- 実体化した上で，手動で編集することもできる

## 型
### 基本型
- Int
	- C++ の std::int64_t 型と対応
- Bool
	- C++ の bool 型と対応
- Float
	- C++ の double 型と対応
- Text
	- 文字列 （2^32 バイト未満）
- Video
	- 映像型
	- height, width は 2^32 未満
	- フレーム数は 2^64 未満
		- 将来的に生放送に対応した場合に桁あふれを防ぐために多めに桁数を持たせている
- Audio
	- 音声型
	- 詳細は未定
- Vector 上記の型の可変長配列 （2^32 個未満）
	- 中に Vector は入れられない (即値の扱いに困るのと，可視化が難しくなるため)

## スケジューリング
### トポロジカルソート
- 主出力と副出力両方の参照関係を用いて，トポロジカルソートを行う。
	- トポロジカルソートに失敗した場合にはスケジューリング不能としてレンダリングに失敗する

### 非因果的システム
- 例えば逆再生などは代表的な非因果的システム
	- 入力パラメータ全体について，未来の値を取れる必要がある
- 各入力に対し，look-ahead, look-behind の値を取る
	- そのエフェクトが発生した時点での，各入力の最新値よりも look-ahead フレーム先と look-behind フレーム前（入力値準拠）を読む必要があることを言明する
	- 原理上， look-behind + look-ahead >= 0 である。
	- 例えば， look-behind = 100, look-ahead = -100 というのも可能
		- 例として，100フレーム前のものを出力し，最初の100フレームはカウントダウン，みたいなエフェクトがこれに該当する
- ここでは，エフェクトを以下の３種類に分ける
	- 群遅延付きエフェクト
		- look-ahead = look-behind = 0
	- リアルタイムエフェクト
		- look-ahead と look-behind がともに有限確定値
	- 強非因果的システム
		- その他 (look-ahead, look-behind = std::nullopt とする)
		- スケジューリング時に，代わりに「入力の全体長」がそれぞれに入力されているとみなして処理する
		- 入力の長さが不定（生放送）かつ強い非因果的システムの場合，スケジューリングに失敗する

### スケジューリング
#### 基本
- トポロジカルソートした結果を rank と呼ぶ （葉ノードの一つは0, 根ノードは最大値で，連番の整数が振られる）
- 各ノードについて「最後に計算された時刻」を記録しておく
- 時間は， fps の分子の最小公倍数をもとに全て整数化し，それを timestamp と呼ぶ (128bit整数)。
- 最終的には， `priority_queue<pair<timestamp, rank>>` から取り出して順に処理していく
	- 処理が終わったら，自分自身を次の timestamp でキューに入れる （fps=0の時を除く）
	- 入力が fps=0 かつ，今の timestamp において未処理なら，それを `pair{timestamp, rank-1}` に入れて，自分自身も今の時刻で入れなおす
#### 遅延計算
- 主出力・副出力両方において，出力ノードのdelay + (look_aheadf×fps分子の最小公倍数/自分のfps) の値を超えない最小の値になる
	- rootから辿ることで決定できる
- 各変数は， (Δtimestamp, rank) の寿命を持つ。Δtimestampは，各消費に対して (look-ahead + look-behind - (delay(destination) - delay(source)) × 自分のfps / fps分子の最小公倍数) の値(割り算は切り上げ)の最大値。0の場合もあるが，最後に消費されるrankの方が効くことで，変数寿命の管理がなされる。

#### キャッシング
- 各値はメモリ上にキャッシングされる。
	- ただし，動画についてのみ，キャッシュを適宜ストレージ側に適宜落とす。
	- 生放送の時には，メモリに乗せる量の上限を非常に大きい値（実質の無制限）にすることが推奨される。

#### 並列処理 (未実装)
- `priority_queue<tuple<ready, timestamp, rank>>` で先頭からどんどん取り出して， semaphore で最大数を管理しつつ並列処理する形になると思う
	- キューが複数になってしまうのは困るので，設計を考え中

### 特筆すべき実例
- 入力の再生 → 逆再生 を繰り返すエフェクトは，強非因果エフェクトなので，生放送のカメラに対して適用すると，スケジューリングに失敗する
	- しかし，同様に生放送中に「全体が1秒の動画」に対してこれを適用すると，１秒の遅延で済み，スケジューリング可能。
- 100フレーム遅延するエフェクトの後に「最初の100フレームはカウントダウンをした後に，100フレーム前の動画を再生するエフェクト（look-ahead = -100, look-behind = 100）」を入れると，遅延は0になる。

